using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;

namespace BlazingApple.Tests.Roslyn.Shared.Analyzers;

/// <summary>Runs a C# code fix</summary>
/// <remarks>This file was condensed from classes generated by MS</remarks>
/// <typeparam name="TAnalyzer">Analyzer to test</typeparam>
/// <typeparam name="TCodeFix">Code fix to test</typeparam>
internal class CSharpCodeFixVerifier<TAnalyzer, TCodeFix>
	where TAnalyzer : DiagnosticAnalyzer, new()
	where TCodeFix : CodeFixProvider, new()
{
	public Func<TCodeFix> CreateCodeFix { get; set; } = () => new TCodeFix();

	public Task VerifyCodeFixAsync(string source, string fixedSource, params DiagnosticResult[] expected)
	{
		Test test = new(this)
		{
			TestCode = source,
			FixedCode = fixedSource,
		};

		test.ExpectedDiagnostics.AddRange(expected);
		return test.RunAsync();
	}

	public class Test : CSharpCodeFixTest<TAnalyzer, TCodeFix, MSTestVerifier>
	{
		private readonly CSharpCodeFixVerifier<TAnalyzer, TCodeFix> _parent;

		public Test(CSharpCodeFixVerifier<TAnalyzer, TCodeFix> parent)
		{
			_parent = parent;
			CSharpAnalyzerVerifier<TAnalyzer>.SetTestDefaults(this);
			FixedState.MarkupHandling = MarkupMode.Allow; // Allow tagging expected diagnostics in output
			CodeFixTestBehaviors = CodeFixTestBehaviors.FixOne; // Don't try to recursively apply the fix multiple times on the same code
		}

		protected override IEnumerable<CodeFixProvider> GetCodeFixProviders()
		{
			yield return _parent.CreateCodeFix();
		}
	}
}
